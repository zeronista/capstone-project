<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Stringee Web Call Demo</title>
    <script src="/js/latest.sdk.bundle.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .box { border: 1px solid #ccc; padding: 20px; margin-bottom: 20px; border-radius: 8px; }
        .status { font-weight: bold; color: blue; }
        .status-connecting { color: orange; }
        .status-connected { color: green; }
        .status-disconnected { color: red; }
        button { padding: 10px 20px; cursor: pointer; margin-right: 10px; }
        .hidden { display: none; }
        .log-box { 
            background: #f5f5f5; 
            border: 1px solid #ddd; 
            padding: 10px; 
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry { 
            margin: 3px 0; 
            padding: 3px;
        }
        .log-info { color: blue; }
        .log-success { color: green; }
        .log-error { color: red; }
        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: red;
            border-radius: 50%;
            animation: blink 1s infinite;
            margin-left: 5px;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        .recording-info {
            margin-top: 10px;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
        }
        .recordings-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        .recording-item {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .recording-item:hover {
            background: #f0f0f0;
        }
        .recording-info-text {
            flex: 1;
        }
        .recording-controls {
            display: flex;
            gap: 5px;
        }
        audio {
            max-width: 300px;
        }
        .no-recordings {
            text-align: center;
            color: #6c757d;
            padding: 20px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Demo Web-to-Web Call</h1>

    <div id="login-screen" class="box">
        <h3>ƒêang ki·ªÉm tra ƒëƒÉng nh·∫≠p...</h3>
        <p id="loginMessage">Vui l√≤ng ƒë·ª£i...</p>
    </div>

    <div id="call-screen" class="box hidden">
        <h3>Xin ch√†o: <span id="displayUserName"></span> (<span id="displayUserId"></span>)</h3>
        <p>
            Tr·∫°ng th√°i k·∫øt n·ªëi: 
            <span id="connectionStatus" class="status status-connecting">ƒêang k·∫øt n·ªëi...</span>
        </p>
        
        <div class="log-box" id="logConsole">
            <div class="log-entry log-info">Nh·∫≠t k√Ω ho·∫°t ƒë·ªông s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>
        </div>
        
        <hr>
        
        <div style="margin-bottom: 10px;">
            <label>
                <input type="checkbox" id="autoRecordCheckbox" checked>
                <strong>üéôÔ∏è T·ª± ƒë·ªông ghi √¢m khi cu·ªôc g·ªçi k·∫øt n·ªëi</strong>
            </label>
            <p style="font-size: 12px; color: #666; margin: 5px 0 0 24px;">
                (File s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông v√†o S3 khi cu·ªôc g·ªçi k·∫øt th√∫c)
            </p>
        </div>
        
        <hr>
        
        <h4>Th·ª±c hi·ªán cu·ªôc g·ªçi</h4>
        <input type="text" id="remoteUserId" placeholder="Nh·∫≠p ID ng∆∞·ªùi nh·∫≠n (v√≠ d·ª•: user2)">
        
        <div style="margin-top: 10px;">
            <button id="btnCall" onclick="makeCall()">üìû G·ªçi Voice</button>
            <button id="btnReject" onclick="rejectCall()" class="hidden" style="background: #dc3545; color: white;">‚õî T·ª´ ch·ªëi</button>
            <button id="btnAnswer" onclick="answerCall()" class="hidden" style="background: green; color: white;">‚úÖ Tr·∫£ l·ªùi</button>
            <button id="btnHangup" onclick="hangupCall()" class="hidden" style="background: red; color: white;">‚ùå K·∫øt th√∫c</button>
        </div>

        <div id="manualRecordButtons" style="margin-top: 10px;">
            <button id="btnStartRecord" onclick="startRecording()" class="hidden" style="background: #007bff; color: white;">üéôÔ∏è B·∫Øt ƒë·∫ßu ghi √¢m</button>
            <button id="btnStopRecord" onclick="stopRecording()" class="hidden" style="background: #6c757d; color: white;">‚èπÔ∏è D·ª´ng ghi √¢m</button>
        </div>

        <p id="callStatus" style="font-weight: bold; margin-top: 10px;">S·∫µn s√†ng</p>
        
        <div id="recordingInfo" class="recording-info hidden">
            <p style="margin: 0;">
                <strong>üéôÔ∏è ƒêang ghi √¢m</strong>
                <span class="recording-indicator"></span>
                <span id="recordingDuration">00:00</span>
            </p>
        </div>
        
        <!-- Danh s√°ch recordings -->
        <div id="recordingsSection" class="recordings-section hidden">
            <h4>
                üìº Danh s√°ch file ghi √¢m ƒë√£ l∆∞u
                <button onclick="loadRecordings()" style="float: right; padding: 5px 10px; font-size: 12px;">üîÑ L√†m m·ªõi</button>
            </h4>
            <div id="recordingsList"></div>
        </div>
    </div>

    <div id="remote_videos" style="display: none;"></div>

    <script>
        // C·∫•u h√¨nh Stringee Server Addresses (Best Practice)
        const STRINGEE_SERVER_ADDRS = [
            "wss://v1.stringee.com:6899/", 
            "wss://v2.stringee.com:6899/"
        ];
        
        var stringeeClient;
        var currentCall;
        var myToken;
        var currentUser = null; // L∆∞u th√¥ng tin user hi·ªán t·∫°i
        var mediaRecorder;
        var recordedChunks = [];
        var recordingStartTime;
        var recordingInterval;
        var localStream = null; // Stream t·ª´ microphone
        var audioContext = null;
        var mixedStream = null;

        // Event listener cho checkbox auto-record
        document.addEventListener('DOMContentLoaded', function() {
            // T·ª± ƒë·ªông load th√¥ng tin user khi trang load
            loadCurrentUser();
            
            const autoRecordCheckbox = document.getElementById('autoRecordCheckbox');
            autoRecordCheckbox.addEventListener('change', function() {
                const manualButtons = document.getElementById('manualRecordButtons');
                if (this.checked) {
                    addLog('‚úÖ ƒê√£ b·∫≠t t·ª± ƒë·ªông ghi √¢m', 'success');
                } else {
                    addLog('‚ÑπÔ∏è ƒê√£ t·∫Øt t·ª± ƒë·ªông ghi √¢m - B·∫°n c·∫ßn b·∫•m n√∫t ƒë·ªÉ ghi √¢m', 'info');
                }
            });
        });

        function addLog(message, type) {
            type = type || 'info';
            const logBox = document.getElementById('logConsole');
            const timestamp = new Date().toLocaleTimeString();
            const logClass = type === 'success' ? 'log-success' : (type === 'error' ? 'log-error' : 'log-info');
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry ' + logClass;
            logEntry.textContent = '[' + timestamp + '] ' + message;
            
            logBox.appendChild(logEntry);
            logBox.scrollTop = logBox.scrollHeight;
        }

        /**
         * Load th√¥ng tin user hi·ªán ƒëang ƒëƒÉng nh·∫≠p
         */
        async function loadCurrentUser() {
            try {
                const response = await fetch('/api/web-call/current-user');
                
                if (!response.ok) {
                    throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin user');
                }
                
                const data = await response.json();
                
                if (data.authenticated) {
                    currentUser = data;
                    console.log('Current user:', currentUser);
                    
                    // T·ª± ƒë·ªông k·∫øt n·ªëi Stringee
                    document.getElementById('loginMessage').textContent = 
                        'Ch√†o ' + currentUser.fullName + '! ƒêang k·∫øt n·ªëi...';
                    
                    await connectStringee();
                } else {
                    // Ch∆∞a ƒëƒÉng nh·∫≠p
                    document.getElementById('login-screen').innerHTML = `
                        <h3>‚ö†Ô∏è Ch∆∞a ƒëƒÉng nh·∫≠p</h3>
                        <p>B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p v√†o h·ªá th·ªëng tr∆∞·ªõc khi s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.</p>
                        <button onclick="window.location.href='/login'" 
                                style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            ƒêƒÉng nh·∫≠p ngay
                        </button>
                    `;
                }
            } catch (err) {
                console.error('L·ªói load current user:', err);
                document.getElementById('loginMessage').textContent = 
                    'L·ªói: ' + err.message + '. Vui l√≤ng th·ª≠ l·∫°i.';
                document.getElementById('login-screen').innerHTML = `
                    <h3>‚ùå L·ªói k·∫øt n·ªëi</h3>
                    <p>${err.message}</p>
                    <button onclick="loadCurrentUser()" 
                            style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        üîÑ Th·ª≠ l·∫°i
                    </button>
                `;
            }
        }

        async function connectStringee() {
            if (!currentUser) {
                alert('Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc');
                return;
            }

            const userId = currentUser.stringeeUserId;
            const userName = currentUser.fullName;

            console.log('B·∫Øt ƒë·∫ßu k·∫øt n·ªëi v·ªõi userId:', userId);
            addLog('ƒêang k·∫øt n·ªëi v·ªõi user: ' + userName, 'info');

            try {
                console.log('ƒêang l·∫•y access token t·ª´ server...');
                addLog('ƒêang l·∫•y access token t·ª´ server...', 'info');
                
                const res = await fetch('/api/web-call/token');
                
                if (!res.ok) {
                    throw new Error('HTTP error! status: ' + res.status + ' - ' + res.statusText);
                }
                
                const data = await res.json();
                
                if (!data.token) {
                    throw new Error('Token kh√¥ng c√≥ trong response t·ª´ server');
                }
                
                myToken = data.token;
                console.log('ƒê√£ nh·∫≠n ƒë∆∞·ª£c token:', myToken.substring(0, 50) + '...');
                addLog('‚úÖ ƒê√£ nh·∫≠n ƒë∆∞·ª£c access token t·ª´ server', 'success');
            } catch (err) {
                console.error('L·ªói l·∫•y token:', err);
                addLog('‚ùå L·ªói l·∫•y token: ' + err.message, 'error');
                alert('L·ªói l·∫•y token t·ª´ server: ' + err.message + '\n\nVui l√≤ng ki·ªÉm tra:\n1. Server ƒëang ch·∫°y\n2. API endpoint ho·∫°t ƒë·ªông\n3. B·∫°n ƒë√£ ƒëƒÉng nh·∫≠p');
                return;
            }

            stringeeClient = new StringeeClient(STRINGEE_SERVER_ADDRS);
            console.log('ƒê√£ kh·ªüi t·∫°o Stringee Client v·ªõi server addresses');
            addLog('ƒê√£ kh·ªüi t·∫°o Stringee Client', 'info');

            stringeeClient.on('connect', function () {
                console.log('ƒê√£ k·∫øt n·ªëi t·ªõi Stringee Server');
                document.getElementById('connectionStatus').innerText = 'üü¢ ƒê√£ k·∫øt n·ªëi';
                document.getElementById('connectionStatus').className = 'status status-connected';
                addLog('ƒê√£ k·∫øt n·ªëi t·ªõi Stringee Server', 'success');
            });

            stringeeClient.on('authen', function (res) {
                console.log('X√°c th·ª±c:', res);
                if (res.r === 0) {
                    console.log('ƒêƒÉng nh·∫≠p th√†nh c√¥ng');
                    document.getElementById('login-screen').classList.add('hidden');
                    document.getElementById('call-screen').classList.remove('hidden');
                    document.getElementById('displayUserId').innerText = currentUser.stringeeUserId;
                    document.getElementById('displayUserName').innerText = currentUser.fullName;
                    addLog('‚úÖ X√°c th·ª±c th√†nh c√¥ng! User: ' + currentUser.fullName, 'success');
                    addLog('B·∫°n c√≥ th·ªÉ th·ª±c hi·ªán cu·ªôc g·ªçi ngay b√¢y gi·ªù', 'success');
                    
                    // Hi·ªÉn th·ªã v√† load danh s√°ch recordings
                    document.getElementById('recordingsSection').classList.remove('hidden');
                    loadRecordings();
                } else {
                    console.error('X√°c th·ª±c th·∫•t b·∫°i:', res);
                    addLog('‚ùå X√°c th·ª±c th·∫•t b·∫°i: ' + res.message, 'error');
                    alert('X√°c th·ª±c th·∫•t b·∫°i: ' + res.message);
                }
            });

            stringeeClient.on('disconnect', function () {
                console.log('ƒê√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi Stringee');
                document.getElementById('connectionStatus').innerText = 'üî¥ ƒê√£ ng·∫Øt k·∫øt n·ªëi';
                document.getElementById('connectionStatus').className = 'status status-disconnected';
                addLog('ƒê√£ ng·∫Øt k·∫øt n·ªëi', 'error');
            });

            stringeeClient.on('requestnewtoken', function () {
                console.log('Token h·∫øt h·∫°n');
                addLog('Token h·∫øt h·∫°n!', 'error');
                alert('Token ƒë√£ h·∫øt h·∫°n. Vui l√≤ng l√†m m·ªõi trang.');
            });

            stringeeClient.on('incomingcall', function (incomingCall) {
                console.log('Cu·ªôc g·ªçi ƒë·∫øn:', incomingCall);
                addLog('üìû Cu·ªôc g·ªçi ƒë·∫øn t·ª´: ' + incomingCall.fromNumber, 'info');
                currentCall = incomingCall;
                
                document.getElementById('callStatus').innerText = 'üìû ƒêang c√≥ cu·ªôc g·ªçi ƒë·∫øn t·ª´: ' + incomingCall.fromNumber;
                document.getElementById('btnAnswer').classList.remove('hidden');
                document.getElementById('btnReject').classList.remove('hidden');
                document.getElementById('btnCall').classList.add('hidden');

                settingCallEvents(currentCall);
            });

            console.log('ƒêang k·∫øt n·ªëi t·ªõi Stringee...');
            stringeeClient.connect(myToken);
        }

        function makeCall() {
            if (!currentUser) {
                alert('Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc');
                return;
            }
            
            const callerId = currentUser.stringeeUserId;
            const calleeId = document.getElementById('remoteUserId').value;

            if (!calleeId) return alert('Nh·∫≠p ID ng∆∞·ªùi nh·∫≠n');

            console.log('ƒêang g·ªçi...');
            addLog('ƒêang g·ªçi t·ªõi: ' + calleeId, 'info');

            currentCall = new StringeeCall(stringeeClient, callerId, calleeId, false);

            settingCallEvents(currentCall);

            currentCall.makeCall(function (res) {
                console.log('makeCall response:', res);
                if (res.r !== 0) {
                    console.error('G·ªçi th·∫•t b·∫°i:', res.message);
                    addLog('G·ªçi th·∫•t b·∫°i: ' + res.message, 'error');
                    alert(res.message);
                } else {
                    addLog('ƒêang th·ª±c hi·ªán cu·ªôc g·ªçi...', 'success');
                }
            });
            
            showInCallUI();
        }

        function settingCallEvents(call) {
            call.on('addremotestream', function (stream) {
                console.log('Adding remote stream');
                addLog('ƒê√£ nh·∫≠n lu·ªìng √¢m thanh t·ª´ ng∆∞·ªùi g·ªçi', 'success');
                
                // T·∫°o video element ƒë·ªÉ play remote stream
                var videoElement = document.createElement('video');
                videoElement.setAttribute('autoplay', '');
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('id', 'remoteAudio');
                
                document.getElementById('remote_videos').appendChild(videoElement);
                stream.play(videoElement);
            });

            call.on('signalingstate', function (state) {
                console.log('Signaling state:', state);
                document.getElementById('callStatus').innerText = state.reason;
                addLog('Tr·∫°ng th√°i: ' + state.reason, 'info');
                
                // Code 3 = Answered - cu·ªôc g·ªçi ƒë√£ ƒë∆∞·ª£c tr·∫£ l·ªùi
                if (state.code === 3) {
                    addLog('‚úÖ Cu·ªôc g·ªçi ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi', 'success');
                    
                    // T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu ghi √¢m n·∫øu b·∫≠t auto-record
                    const autoRecord = document.getElementById('autoRecordCheckbox').checked;
                    if (autoRecord) {
                        addLog('üéôÔ∏è B·∫Øt ƒë·∫ßu t·ª± ƒë·ªông ghi √¢m...', 'info');
                        // Delay nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o UI ƒë√£ s·∫µn s√†ng
                        setTimeout(() => startRecording(), 500);
                    }
                }
                
                if (state.code === 6) {
                    addLog('Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c', 'success');
                    resetUI();
                }
            });

            call.on('mediastate', function (state) {
                console.log('Media state:', state);
            });
            
            call.on('info', function (info) {
                console.log('Call info:', info);
            });
        }

        function answerCall() {
            if (currentCall) {
                currentCall.answer(function (res) {
                    console.log('answer res', res);
                    if (res.r === 0) {
                        showInCallUI();
                        
                        // T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu ghi √¢m n·∫øu b·∫≠t auto-record (cho ng∆∞·ªùi nh·∫≠n cu·ªôc g·ªçi)
                        const autoRecord = document.getElementById('autoRecordCheckbox').checked;
                        if (autoRecord) {
                            addLog('üéôÔ∏è B·∫Øt ƒë·∫ßu t·ª± ƒë·ªông ghi √¢m...', 'info');
                            // Delay ƒë·ªÉ ƒë·∫£m b·∫£o cu·ªôc g·ªçi ƒë√£ k·∫øt n·ªëi ho√†n to√†n
                            setTimeout(() => startRecording(), 1000);
                        }
                    }
                });
            }
        }

        function rejectCall() {
            if (currentCall) {
                // G·ªçi h√†m reject c·ªßa SDK
                currentCall.reject(function (res) {
                    console.log('reject res', res);
                    if (res.r === 0) {
                        addLog('ƒê√£ t·ª´ ch·ªëi cu·ªôc g·ªçi', 'info');
                    } else {
                        addLog('L·ªói t·ª´ ch·ªëi: ' + res.message, 'error');
                    }
                });
                // Reset giao di·ªán ngay l·∫≠p t·ª©c sau khi b·∫•m t·ª´ ch·ªëi
                resetUI();
            }
        }

        function hangupCall() {
            if (currentCall) {
                currentCall.hangup(function (res) {
                    console.log('hangup res', res);
                });
            }
            resetUI();
        }

        function showInCallUI() {
            document.getElementById('btnCall').classList.add('hidden');
            document.getElementById('btnAnswer').classList.add('hidden');
            document.getElementById('btnReject').classList.add('hidden');
            document.getElementById('btnHangup').classList.remove('hidden');
            
            // Ch·ªâ hi·ªÉn n√∫t ghi √¢m th·ªß c√¥ng n·∫øu t·∫Øt auto-record
            const autoRecord = document.getElementById('autoRecordCheckbox').checked;
            if (!autoRecord) {
                document.getElementById('btnStartRecord').classList.remove('hidden');
            }
        }

        function resetUI() {
            // T·ª± ƒë·ªông d·ª´ng v√† upload recording n·∫øu ƒëang ghi
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                addLog('ƒêang k·∫øt th√∫c ghi √¢m v√† upload...', 'info');
                stopRecording();
            }
            
            // Cleanup streams
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            mixedStream = null;
            
            document.getElementById('callStatus').innerText = 'S·∫µn s√†ng';
            document.getElementById('btnCall').classList.remove('hidden');
            document.getElementById('btnAnswer').classList.add('hidden');
            document.getElementById('btnHangup').classList.add('hidden');
            document.getElementById('btnReject').classList.add('hidden');
            document.getElementById('btnStartRecord').classList.add('hidden');
            document.getElementById('btnStopRecord').classList.add('hidden');
            document.getElementById('recordingInfo').classList.add('hidden');
            document.getElementById('remote_videos').innerHTML = '';
            currentCall = null;
        }

        /**
         * B·∫Øt ƒë·∫ßu ghi √¢m
         * - T·ª± ƒë·ªông: ƒë∆∞·ª£c g·ªçi khi cu·ªôc g·ªçi k·∫øt n·ªëi, ghi t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi
         * - Th·ªß c√¥ng: user b·∫•m n√∫t, ghi khi n√†o mu·ªën
         */
        async function startRecording() {
            try {
                // N·∫øu ƒëang recording r·ªìi th√¨ b·ªè qua
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    addLog('‚ÑπÔ∏è ƒêang ghi √¢m r·ªìi', 'info');
                    return;
                }
                
                addLog('üéôÔ∏è ƒêang kh·ªüi t·∫°o ghi √¢m...', 'info');
                
                // L·∫•y local stream t·ª´ microphone
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                addLog('‚úÖ ƒê√£ l·∫•y local stream (microphone)', 'success');
                
                // T·∫°o AudioContext ƒë·ªÉ mix streams
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const destination = audioContext.createMediaStreamDestination();
                
                // Th√™m local stream (microphone)
                const localSource = audioContext.createMediaStreamSource(localStream);
                localSource.connect(destination);
                addLog('‚úÖ ƒê√£ k·∫øt n·ªëi local stream', 'success');
                
                // Th·ª≠ th√™m remote stream n·∫øu c√≥
                const remoteAudioElement = document.getElementById('remoteAudio');
                if (remoteAudioElement && remoteAudioElement.srcObject) {
                    try {
                        const remoteSource = audioContext.createMediaStreamSource(remoteAudioElement.srcObject);
                        remoteSource.connect(destination);
                        addLog('‚úÖ ƒê√£ k·∫øt n·ªëi remote stream', 'success');
                    } catch (err) {
                        console.error('L·ªói k·∫øt n·ªëi remote stream:', err);
                        addLog('‚ö†Ô∏è Kh√¥ng th·ªÉ ghi remote stream: ' + err.message, 'error');
                    }
                } else {
                    addLog('‚ö†Ô∏è Ch·ªâ ghi √¢m local (ch∆∞a c√≥ remote stream)', 'info');
                }
                
                // S·ª≠ d·ª•ng mixed stream ƒë·ªÉ ghi √¢m
                mixedStream = destination.stream;
                
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(mixedStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                        console.log('Chunk received:', event.data.size, 'bytes');
                    }
                };

                mediaRecorder.onstop = async () => {
                    addLog('ƒê√£ d·ª´ng MediaRecorder, ƒëang x·ª≠ l√Ω...', 'info');
                    
                    // D·ª´ng t·∫•t c·∫£ tracks
                    if (localStream) {
                        localStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('Stopped local track:', track.kind);
                        });
                    }
                    
                    // ƒê√≥ng AudioContext
                    if (audioContext) {
                        audioContext.close();
                    }
                    
                    // T·∫°o blob t·ª´ chunks
                    if (recordedChunks.length > 0) {
                        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                        console.log('Created blob:', blob.size, 'bytes');
                        addLog('ƒê√£ t·∫°o file ghi √¢m: ' + (blob.size / 1024).toFixed(2) + ' KB', 'success');
                        
                        // Upload l√™n server
                        await uploadRecording(blob);
                    } else {
                        addLog('‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu ghi √¢m', 'error');
                    }
                    
                    // Clear interval
                    if (recordingInterval) {
                        clearInterval(recordingInterval);
                    }
                    
                    // Reset variables
                    localStream = null;
                    audioContext = null;
                    mixedStream = null;
                };

                mediaRecorder.start(100); // Thu th·∫≠p data m·ªói 100ms
                recordingStartTime = Date.now();
                
                addLog('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu ghi √¢m c·∫£ 2 chi·ªÅu', 'success');
                
                // Hi·ªÉn th·ªã UI
                document.getElementById('btnStartRecord').classList.add('hidden');
                document.getElementById('btnStopRecord').classList.remove('hidden');
                document.getElementById('recordingInfo').classList.remove('hidden');
                
                // C·∫≠p nh·∫≠t duration
                recordingInterval = setInterval(() => {
                    const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                    const seconds = (duration % 60).toString().padStart(2, '0');
                    document.getElementById('recordingDuration').textContent = minutes + ':' + seconds;
                }, 1000);
                
            } catch (err) {
                console.error('L·ªói khi b·∫Øt ƒë·∫ßu ghi √¢m:', err);
                addLog('‚ùå L·ªói: ' + err.message, 'error');
                alert('Kh√¥ng th·ªÉ truy c·∫≠p microphone. Vui l√≤ng cho ph√©p truy c·∫≠p.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                document.getElementById('btnStartRecord').classList.remove('hidden');
                document.getElementById('btnStopRecord').classList.add('hidden');
                document.getElementById('recordingInfo').classList.add('hidden');
                
                addLog('ƒê√£ d·ª´ng ghi √¢m. ƒêang upload l√™n S3...', 'info');
            }
        }

        async function uploadRecording(blob) {
            try {
                if (!blob || blob.size === 0) {
                    addLog('‚ùå File ghi √¢m tr·ªëng, kh√¥ng th·ªÉ upload', 'error');
                    return;
                }
                
                if (!currentUser) {
                    addLog('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin user', 'error');
                    return;
                }
                
                const userId = currentUser.stringeeUserId;
                const remoteUserId = document.getElementById('remoteUserId').value || 'unknown';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `call_${userId}_to_${remoteUserId}_${timestamp}.webm`;
                
                addLog(`üì¶ Chu·∫©n b·ªã upload file: ${filename} (${(blob.size / 1024).toFixed(2)} KB)`, 'info');
                
                const formData = new FormData();
                formData.append('file', blob, filename);
                formData.append('callId', 'web_' + Date.now());
                formData.append('userId', userId);
                
                addLog('‚òÅÔ∏è ƒêang upload file ghi √¢m l√™n S3...', 'info');
                
                const response = await fetch('/api/stringee/upload-recording', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    addLog('‚úÖ Upload th√†nh c√¥ng! File: ' + result.s3Key, 'success');
                    addLog('üîó URL: ' + result.presignedUrl, 'success');
                    console.log('S3 Key:', result.s3Key);
                    console.log('Pre-signed URL:', result.presignedUrl);
                    
                    // L√†m m·ªõi danh s√°ch recordings
                    setTimeout(() => loadRecordings(), 1000);
                } else {
                    addLog('‚ùå Upload th·∫•t b·∫°i: ' + (result.error || 'Unknown error'), 'error');
                }
                
            } catch (err) {
                console.error('L·ªói upload:', err);
                addLog('‚ùå L·ªói upload: ' + err.message, 'error');
            }
        }

        /**
         * Load danh s√°ch recordings t·ª´ S3
         */
        async function loadRecordings() {
            try {
                addLog('üîÑ ƒêang t·∫£i danh s√°ch file ghi √¢m...', 'info');
                
                const response = await fetch('/api/stringee/recordings');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    displayRecordings(result.recordings);
                    addLog(`‚úÖ T·∫£i ƒë∆∞·ª£c ${result.count} file ghi √¢m`, 'success');
                } else {
                    addLog('‚ùå L·ªói: ' + result.error, 'error');
                }
                
            } catch (err) {
                console.error('L·ªói load recordings:', err);
                addLog('‚ùå L·ªói t·∫£i danh s√°ch: ' + err.message, 'error');
            }
        }

        /**
         * Hi·ªÉn th·ªã danh s√°ch recordings
         */
        function displayRecordings(recordings) {
            const container = document.getElementById('recordingsList');
            
            if (!recordings || recordings.length === 0) {
                container.innerHTML = '<div class="no-recordings">Ch∆∞a c√≥ file ghi √¢m n√†o</div>';
                return;
            }
            
            let html = '';
            
            recordings.forEach((rec, index) => {
                const filename = rec.filename;
                const size = (rec.size / 1024).toFixed(2);
                const date = new Date(rec.lastModified).toLocaleString('vi-VN');
                
                html += `
                    <div class="recording-item">
                        <div class="recording-info-text">
                            <strong>üìÅ ${filename}</strong><br>
                            <small style="color: #6c757d;">
                                üìÖ ${date} | üíæ ${size} KB
                            </small>
                        </div>
                        <div class="recording-controls">
                            <button onclick="playRecording('${rec.url}', '${filename}')" 
                                    style="background: #28a745; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer;">
                                ‚ñ∂Ô∏è Nghe
                            </button>
                            <button onclick="downloadRecording('${rec.url}', '${filename}')" 
                                    style="background: #17a2b8; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer;">
                                ‚¨áÔ∏è T·∫£i
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        /**
         * Ph√°t file ghi √¢m
         */
        function playRecording(url, filename) {
            addLog('‚ñ∂Ô∏è ƒêang ph√°t: ' + filename, 'info');
            
            // T·∫°o audio player modal
            const existingModal = document.getElementById('audioPlayerModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.id = 'audioPlayerModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 400px;
            `;
            
            modal.innerHTML = `
                <h4 style="margin-top: 0;">üéµ ${filename}</h4>
                <audio controls autoplay style="width: 100%; margin: 15px 0;">
                    <source src="${url}" type="audio/webm">
                    Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ audio.
                </audio>
                <button onclick="document.getElementById('audioPlayerModal').remove()" 
                        style="width: 100%; padding: 10px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    ƒê√≥ng
                </button>
            `;
            
            document.body.appendChild(modal);
            
            // Th√™m backdrop
            const backdrop = document.createElement('div');
            backdrop.onclick = () => {
                modal.remove();
                backdrop.remove();
            };
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            document.body.insertBefore(backdrop, modal);
        }

        /**
         * T·∫£i xu·ªëng file ghi √¢m
         */
        function downloadRecording(url, filename) {
            addLog('‚¨áÔ∏è ƒêang t·∫£i: ' + filename, 'info');
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            addLog('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu t·∫£i file', 'success');
        }
    </script>
</body>
</html>
